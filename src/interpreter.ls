#-----------------------------------------------------------------------------#
# interpreter.ls
#
# Core interpreter code
#
# Some structures this uses:
#
# A scope object has a __parent__ property for its parent scope; any other
# properties represent its variables directly.
# 
# A function object has a __type__ property. This is either:
#   'NativeFunction':  In this case the function's __value__ property is the
#                      native JS function.
#   'DefinedFunction': In this case it has the properties __params__, __body__,
#                      and __scope__. The __params__ property is an array of
#                      variable names, the __body__ is the Esprima-parsed body,
#                      and the __scope__ is the scope object where it was
#                      defined.
#-----------------------------------------------------------------------------#

{map, listsToObj} = require 'prelude-ls'

#-----------------------------------------------------------------------------#
# Exports to the UI
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #

@globalScope = __parent__: null

@init = ->
  globalScope.log =
    __type__: 'NativeFunction'
    __value__: printInConsole

# Executes code (as a string) typed in by the user.
@run = (code) ->
  console.log parsedCode = esprima.parse code
  for statement in parsedCode.body
    switch statement.type
    | 'ExpressionStatement' =>
      showResult . evaluate globalScope <| statement.expression
    | _ => execute statement, globalScope

#-----------------------------------------------------------------------------#

# Searches up the scope chain and sets the variable where it first finds it,
# or in the global scope if it's not found.
setVariable = (scope, name, value) ->
  if scope.hasOwnProperty(name) or not scope.__parent__?
    scope[name] = value
  else
    setVariable(scope.__parent__, name, value)

#-----------------------------------------------------------------------------#
# Core eval/apply and statement execution functions
#
# The evaluate and execute functions match on the output generated by Esprima.
# See http://esprima.org/demo/parse.html for examples.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #

# This would normally be called "eval", but that name's already taken in JS.
evaluate = (scope, expr) -->
  switch expr.type
  | 'Literal' => expr.value
  | 'Identifier' => scope[expr.name]
  | 'CallExpression' =>
    expr.arguments |> map (evaluate scope)
                   |> apply evaluate(scope, expr.callee)
  | 'BinaryExpression' =>
    switch expr.operator
    | '+' => evaluate(scope, expr.left) + evaluate(scope, expr.right)
    | '*' => evaluate(scope, expr.left) * evaluate(scope, expr.right)
    | _ => void
  | 'FunctionExpression' =>
    __type__: 'DefinedFunction'
    __params__: expr.params.map (.name)
    __body__: expr.body
    __scope__: scope
  | 'AssignmentExpression' =>
    switch expr.operator
    | '=' => setVariable(scope, expr.left.name, evaluate(scope, expr.right))

apply = (f, args) -->
  switch f?.__type__
  | 'NativeFunction' => f.__value__ ...args
  | 'DefinedFunction' =>
    newScope = f.__scope__ with
      (lists-to-obj f.__params__, args) <<< __parent__: f.__scope__
    execute f.__body__, newScope
  | _ =>
    printInConsole "TypeError: #{typeof f} is not a function"
    void

execute = (statement, scope) !->
  switch statement.type
  | 'ExpressionStatement' => evaluate scope, statement.expression
  | 'VariableDeclaration' =>
    for declaration in statement.declarations
      scope[declaration.id.name] = if declaration.init?
        evaluate scope, that
      else
        void
  | 'BlockStatement' =>
    for substatement in statement.body
      switch substatement.type
      | 'ReturnStatement' => return evaluate scope, substatement.argument
      | _ => execute substatement, scope
